## 다양한 그래프 알고리즘

### 이미 배운 내용을 훑어보자
* 크루스칼 알고리즘 -> 그리디 알고리즘으로 분류, 위상 정렬 알고리즘 -> 큐,스택활용
* 서로다른 개체가 연결되어 있다 -> 그래프 알고리즘
* 트리 자료구조는 다양한 알고리즘에서 사용, 수학에서는 무방향 그래프로 간주하나, 컴퓨터공학에선 방향그래프로 간주
* 인접행렬과 인접리스트 방식의 그래프 구현 방법 비교 ex) 노드의 개수 V, 간선의 개수 E
+ 인접행렬 : O(V^2)의 메모리, O(1)의 시간복잡도
+ 인접리스트 : O(E)의 메모리, O(V)의 시간복잡도

#### 서로소 집합
* 서로소 집합 : 공통 원소가 없는 두 집합
* 서로소 집합 자료구조는 union과 find 두개의 연산으로 조작할 수 있다. 
+ union : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
+ find : 특정 원소가 속한 집합을 알려주는 연산

###### 서로소 집합 자료구조
* 트리 자료구조를 이용하여 집합을 표현
* 서로소 집합 계산 알고리즘
+ 1. union연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다.
+   1-1. A와 B의 루트 노드 A', B'를 각각 찾는다.
+   1-2. A'를 B'의 부모 노드로 설정한다(B'가 A'를 가리키도록 설정)
+ 2. 모든 union연산을 처리할 때까지 첫번째 과정을 반복한다.
* 코드 구현 순서
+ 1. 노드의 개수와 간선의 개수 입력받기, 부모테이블 초기화(자기 자신으로)
+ 2. union 연산을 입력받음(입력과 동시에 union연산 진행)
+ 3. 각 원소가 속한 루트노드 출력
+ 4. 부모 테이블 내용 출력
+ 5. find_parent함수와 union_parent함수 구현
* 주의점
+ find함수가 매우 비효율적, 최악의 경우 모든 노드를 확인하여 시간복잡도가 O(V)
+ ex) 1<-2<-3<-4<-5 인경우 부모테이블은 1 1 2 3 4 로 적용되어 find 사용이 비효율적
+ 노드의 개수가 V개이고 find, union연산의 개수가 M개일 때 시간복잡도는 O(VM)
+ 경로압축 기법으로 시간복잡도 개선이 가능
+ -> find함수를 재귀적으로 호출한 뒤 부모테이블 값을 갱신

###### 서로소 집합 알고리즘의 시간복잡도(경로압축 방법만을 이용할 경우)
* 노드 개수 V, 최대 V-1개의 union연산과 M개의 find 연산이 가능할 경우
* -> O(V+M(1+log_2-M/V_V))
* 경로압축 외에도, 시간복잡도를 줄이는 방법은 다양, 코테 수준에서는 경로압축만해도 충분

###### 서로소 집합을 활용한 사이클 판별
* 무방향 그래프에서의 사이클 판별은 서로소 집합 알고리즘으로 판별 가능
* 방향 그래프의 사이클 판별을 DFS를 활용
* 간선을 하나씩 모두 확인하며, union연산으로 노드의 집합을 합쳐줌. 이로써 사이클 판별
+ 1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.
+   1-1. 루트 노드가 서로 다르다면 두 노드에 대하여 union연산을 수행한다.
+   1-2. 루트 노드가 서로 같다면 사이클(Cycle)이 발생한 것.
+ 2. 그래프에 포함되어 있는 모든 간선에 대하여 1번과정을 반복
* 코드 구현 순서
+ 1. 노드, 간선의 개수 입력받기
+ 2. 부모테이블 초기화 및 사이클여부를 저장한 변수 선언
+ 3. 입력 받을 시마다 부모테이블 갱신(사이클 발생 시 종료, 아닐 경우 합집합 수행)
+ 4. find, union함수 구현

#### 신장 트리
* 하나의 그래프에서 모든 노드가 연결되어 있으나, 사이클이 존재하지 않는 부분 그래프 -> 트리의 조건이 모두 갖춰짐
* N개의 도시가 존재할 때 전체 도시가 연결되도록 도로를 놓기 등
###### 크루스칼 알고리즘
* 그리디로 분류되며 대표정인 최소 신장 트리 알고리즘이다.
* 코드 구현 순서
+ 1. 간선 데이터를 비용에 따라 오름차순으로 정렬한다. 
+ 2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인한다.
+   2-1. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다.
+   2-2. 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
+ 3. 모든 간선에 대하여 2번과정을 반복한다.
* 크루스칼 알고리즘의 시간복잡도
+ 간선의 개수가 E개일 때, O(ElogE)의 시간복잡도를 가짐, 정렬하는 작업이 가장오래걸리며 정렬의 시간복잡도가 O(ElogE)이기 때문
+ 힙 정렬의 시간복잡도는 O(NlogN)이다. 따라서 내가 따로 구현해본 힙 정렬 크루스칼 알고리즘도 시간적 효율성을 가지지 못하게 되었다.

#### 위상 정렬
* 사이클이 없는 방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'
* -> DAG(Direct Acyclic Graph) : 유향 비순환 그래프(방향 순환이 없는 무한 유향 그래프)
* ex) 선수과목을 고려한 학습 순서 설정
+ 진입차수 : 특정한 노드로 들어오는 간선의 개수
+ 진출차수 : 특정한 노드에서 나가는 간선의 개수
* 위상 정렬 알고리즘
+ 1. 진입 차수가 0인 노드를 큐에 넣는다.
+ 2. 큐가 빌 때까지 다음의 과정을 반복한다.
+   2-1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.
+   2-2. 새롭게 진입차수가 0이된 노드를 큐에 넣는다.
* 주의점
+ 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재하는 것임
+ 사이클이 존재하는 경우 사이클에 포함되는 원소중 어떤 원소도 큐에 들어가지 못함

## 팀 결성 실전문제

