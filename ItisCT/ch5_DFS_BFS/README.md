# DFS, BFS

## 1. 꼭 필요한 자료구조

### 1. Stack
  * 선입후출, 후입선출구조
  * 별도의 라이브러리가 필요 없으며, append() 와 pop() 메서드를 이용하면 스택 자료구조와 동일하게 동작
    + append() : 리스트의 가장 뒤쪽에 데이터 삽입
    + pop() : 리스트의 가장 뒤쪽에서 데이터를 꺼냄
    + stack[::-1] 역순으로 출력 시 사용



### 2. Queue
  * 선입선출구조
  * python에서 큐를 구현하기 위해 popleft()함수를 쓰려면 collection 모듈의 deque를 import하여야 한다.
  * deque는 queue라이브러리보다 간단하며, 스택과 큐의 장점을 모두 채택한 라이브러리이다.
    + deque 객체에 list()메서드를 이용하면 리스트로 변환하여 사용할 수 있다.
    + 역순으로 바꿀 경우 queue.reverse()


### 3. Recursion(재귀함수)
  * 자기 자신을 다시 호출하는 함수
  * 함수가 무한히 호출되기 때문에 종료조건이 필요
 
 
### 4. 재귀함수의 종료조건
  * 재귀함수를 다룰 경우 함수는 자기 자신을 호출하기 전, 후로 나뉘어진다.
  * 자기 자신 호출 이전의 함수는 입력값부터 종료조건까지 순차적으로 동작한다.
  * 자기 자신 호출 이전의 함수 동작이 모두 종료된다.
  * 자기 자신 호출 이후의 함수는 종료조건부터 입력값까지 순차적으로 동작한다.
  * 재귀함수가 종료된다.
  
### 5. 2가지 방식으로 구현한 팩토리얼 예제

## 2. 탐색 알고리즘 DFS/BFS

### 6. 인접행렬방식
 * 2차원 배열에 각 노드가 연결된 형태를 기록
 * 연결이 되어 있지 않은 노드끼리는 무한 비용이라고 작성하며, 실제로 정답이 될 수 없는 큰 값 등으로 초기화하는 경우가 많다.


### 7. 인접리스트방식
 * 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장
  + 노드개수 크기의 리스트 생성
    ex) graph = [[] for _ in range(3)]
  + 각 노드에 연결되어 있는 간선과 노드를 append하여 추가함
    ex) graph[0].end((연결된 노드번호, 노드를 연결한 간선))
    -> graph[0].append((1,7)) // 0번노드에 이어진 1번노드는 7번간선으로 연결되어있음
    
    
### 8. DFS 예제
 ##### 알고리즘 설계
 * 사용할 변수 정의
  + 1. 방문노드를 확인할 배열 정의
  + 2. 노드와 간선을 정리한 2차원 배열 정의
  + 3. 함수 정의
 * 함수 설계
  + 1. 함수 인자로 노드와 간선정보, 시작노드, 방문확인배열 입력
  + 2. 시작 노드를 방문체크 및 출력
  + 3. 시작인자와 연결된 노드를 재귀함수로 방문(방문하지 않은 노드임을 확인하고 재귀함수를 사용)
  ###### ※ 재귀함수 구현 시 원하는 루틴을 모두 수행하는 점이 중요하며, 루틴을 수행하며 맞는 조건이 발생할 때마다 재귀함수가 수행되도록 함.
  ######    ex) 위 배열에서 1번 노드와 연결된 노드는 2번, 3번, 8번 노드이다. for문에서는 정리된 2차원배열[1] 만 모두 돌게 설계하며, 
  ######        설계가 끝난 후 재귀함수를 호출하면 해당하는 노드들도 순차적으로 모두 순회하게 된다.
