# DFS, BFS

## 1. 꼭 필요한 자료구조

### 1. Stack
  * 선입후출, 후입선출구조
  * 별도의 라이브러리가 필요 없으며, append() 와 pop() 메서드를 이용하면 스택 자료구조와 동일하게 동작
    + append() : 리스트의 가장 뒤쪽에 데이터 삽입
    + pop() : 리스트의 가장 뒤쪽에서 데이터를 꺼냄
    + stack[::-1] 역순으로 출력 시 사용



### 2. Queue
  * 선입선출구조
  * python에서 큐를 구현하기 위해 popleft()함수를 쓰려면 collection 모듈의 deque를 import하여야 한다.
  * deque는 queue라이브러리보다 간단하며, 스택과 큐의 장점을 모두 채택한 라이브러리이다.
    + deque 객체에 list()메서드를 이용하면 리스트로 변환하여 사용할 수 있다.
    + 역순으로 바꿀 경우 queue.reverse()


### 3. Recursion(재귀함수)
  * 자기 자신을 다시 호출하는 함수
  * 함수가 무한히 호출되기 때문에 종료조건이 필요
 
 
### 4. 재귀함수의 종료조건
  * 재귀함수를 다룰 경우 함수는 자기 자신을 호출하기 전, 후로 나뉘어진다.
  * 자기 자신 호출 이전의 함수는 입력값부터 종료조건까지 순차적으로 동작한다.
  * 자기 자신 호출 이전의 함수 동작이 모두 종료된다.
  * 자기 자신 호출 이후의 함수는 종료조건부터 입력값까지 순차적으로 동작한다.
  * 재귀함수가 종료된다.
  
### 5. 2가지 방식으로 구현한 팩토리얼 예제

## 2. 탐색 알고리즘 DFS/BFS

### 6. 인접행렬방식
 * 2차원 배열에 각 노드가 연결된 형태를 기록
 * 연결이 되어 있지 않은 노드끼리는 무한 비용이라고 작성하며, 실제로 정답이 될 수 없는 큰 값 등으로 초기화하는 경우가 많다.


### 7. 인접리스트방식
 * 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장
  + 노드개수 크기의 리스트 생성
    ex) graph = [[] for _ in range(3)]
  + 각 노드에 연결되어 있는 간선과 노드를 append하여 추가함
    ex) graph[0].end((연결된 노드번호, 노드를 연결한 간선))
    -> graph[0].append((1,7)) // 0번노드에 이어진 1번노드는 7번간선으로 연결되어있음
    
    
### 8. DFS 예제
 ##### 알고리즘 설계
 * 사용할 변수 정의
  + 방문노드를 확인할 배열 정의
  + 노드와 간선을 정리한 2차원 배열 정의
  + 함수 정의
 * 함수 설계
  + 함수 인자로 노드와 간선정보, 시작노드, 방문확인배열 입력
  + 시작 노드를 방문체크 및 출력
  + 시작인자와 연결된 노드를 재귀함수로 방문(방문하지 않은 노드임을 확인하고 재귀함수를 사용)
  ###### ※ 재귀함수 구현 시 원하는 루틴을 모두 수행하는 점이 중요하며, 루틴을 수행하며 맞는 조건이 발생할 때마다 재귀함수가 수행되도록 함.
  ######    ex) 위 배열에서 1번 노드와 연결된 노드는 2번, 3번, 8번 노드이다. for문에서는 정리된 2차원배열[1] 만 모두 돌게 설계하며, 
  ######        설계가 끝난 후 재귀함수를 호출하면 해당하는 노드들도 순차적으로 모두 순회하게 된다.



### 9. BFS 예제
  ##### 알고리즘 설계
  * 사용할 변수 정의
    + 방문노드 확인배열 정의
    + 노드와 간선을 정리한 2차원 배열 정의 =
    + 함수 정의
    + 사용할 deque라이브러리 import
  * 함수 설계 
    + 함수 인자로 노드와 간선정보, 시작노드 방문확인배열 입력
    + 시작인자를 queue에 넣고 시작, while문은 queue가 empty상태가 될때까지 동작
    ###### ※ while문이 비어있게 되면 종료되도록 설계, while문이 시작되기 전에 queue에 시작노드를 넣고, 방문배열수정
    ######    while문이 시작하자마자 queue에 있는 값을 빼내고, 연결되어 있는 노드를 모두 queue에 붙임
    ######    while문 두번째 바퀴가 시작되면 하나를 빼고 연결된 모든 노드를 다시 붙이고, 이를 반복
    ######    붙임과 동시에 방문 확인배열을 수정하여야 함.


### 10. 음료수 얼려먹기_실전문제
  ######   1. 문제 재정의
  N * M크기의 얼음 틀에, 생성되는 아이스크림의 개수 출력하기
  ######   2. 조건
  
  ######   3. 알고리즘 설계
  * 사용할 변수 정의
    + 입력값 N, M, inarr
    + answer(답), 
  * 해당 위치와 인접한 0들을 1로 바꿔줄 함수 설계
    + 틀을 벗어나는 경우 종료
    + 현재 위치가 1인 경우 종료
    + 현재 위치가 인 경우 상하좌우 칸에 함수를 적용하여 1로 바꿔줌
  * 2중 for문을 사용하여 모든 칸을 거쳐가며, 0인경우 해당 함수를 호출하고, 갯수를 하나 추가함
    ※ 해당함수를 호출할 경우 인접한 모든 0이 1로 변하기때문에 answer는 하나만 증가
    
### 11. _실전문제
  ######   1. 문제 재정의
  N * M 크기 미로의 0,0에서 N-1, M-1까지의 최단경로(벽은0, 길은1)
  ######   2. 조건
  
  ######   3. 알고리즘 설계
  * 사용할 변수 정의
    + 입력값 N, M, graph
    + 이동관련 함수 정의
  * 거쳐간 경로를 확인할 함수 설계
    + 함수가 시작할때 전달받은 인자값을 큐에 추가
    + 이후 큐가 비어있을 때까지 while문 순회
    + 저장된 방향정보로, 현재 위치에서 이동할 수 있는 위치 구현
    + 이동 가능한 위치의 값을 현재 값 +1하여 거리 저장